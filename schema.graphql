"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type AccessRule {
  disallowed: String
}

enum ActiveFeatureFlag {
  CEPH_VOLUMES
  DEFAULT_TO_RAILPACK
  LOG_EXPLORER_V2
  NEW_GH_REPOS_API
  PRIORITY_BOARDING
  V3_NEW_PROJECT_PAGE
}

enum ActivePlatformFlag {
  COMPRESS_VOLUME_MIGRATION
  DEFAULT_NEW_USERS_RAILPACK
  DEMO_PERCENTAGE_ROLLOUT
  ENABLE_METAL_REGISTRY_AMS
  ENABLE_METAL_REGISTRY_DC4
  ENABLE_METAL_REGISTRY_GCP_REGIONS
  ENABLE_METAL_REGISTRY_SG3
  ENABLE_METAL_REGISTRY_SV2
  NON_DESTRUCTIVE_VOLUME_MIGRATIONS
  REFERRAL_CASH
  RESUMABLE_VOLUME_MIGRATION
  UPDATED_VM_QUERIES
}

enum ActiveServiceFeatureFlag {
  COPY_VOLUME_TO_ENVIRONMENT
  NON_DESTRUCTIVE_VOLUME_MIGRATIONS
  PLACEHOLDER
}

type AdoptionInfo implements Node {
  adoptionLevel: Float
  createdAt: DateTime!
  customer: Team!
  deltaLevel: Float
  id: ID!
  matchedIcpEmail: String
  monthlyEstimatedUsage: Float
  numConfigFile: Int!
  numCronSchedule: Int!
  numDeploys: Int!
  numEnvs: Int!
  numFailedDeploys: Int!
  numHealthcheck: Int!
  numIconConfig: Int!
  numRegion: Int!
  numReplicas: Int!
  numRootDirectory: Int!
  numSeats: Int!
  numServices: Int!
  numSupportRequests: Int!
  numVariables: Int!
  numWatchPatterns: Int!
  totalCores: Float
  totalDisk: Float
  totalNetwork: Float
  updatedAt: DateTime!
}

"""The aggregated usage of a single measurement."""
type AggregatedUsage {
  """The measurement that was aggregated."""
  measurement: MetricMeasurement!

  """
  The tags that were used to group the metric. Only the tags that were used in the `groupBy` will be present.
  """
  tags: MetricTags!

  """The aggregated value."""
  value: Float!
}

type AllDomains {
  customDomains: [CustomDomain!]!
  serviceDomains: [ServiceDomain!]!
}

type ApiToken implements Node {
  displayToken: String!
  id: ID!
  name: String!
  teamId: String
}

input ApiTokenCreateInput {
  name: String!
  teamId: String
}

type BanReasonHistory implements Node {
  actor: User!
  banReason: String
  createdAt: DateTime!
  id: ID!
}

input BaseEnvironmentOverrideInput {
  baseEnvironmentOverrideId: String
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

"""The billing period for a customers subscription."""
type BillingPeriod {
  end: DateTime!
  start: DateTime!
}

enum Builder {
  HEROKU
  NIXPACKS
  PAKETO
  RAILPACK
}

enum CDNProvider {
  DETECTED_CDN_PROVIDER_CLOUDFLARE
  DETECTED_CDN_PROVIDER_UNSPECIFIED
  UNRECOGNIZED
}

scalar CanvasConfig

type CertificatePublicData {
  domainNames: [String!]!
  expiresAt: DateTime
  fingerprintSha256: String!
  issuedAt: DateTime
  keyType: KeyType!
}

enum CertificateStatus {
  CERTIFICATE_STATUS_TYPE_ISSUE_FAILED
  CERTIFICATE_STATUS_TYPE_ISSUING
  CERTIFICATE_STATUS_TYPE_UNSPECIFIED
  CERTIFICATE_STATUS_TYPE_VALID
  CERTIFICATE_STATUS_TYPE_VALIDATING_OWNERSHIP
  UNRECOGNIZED
}

type CnameCheck {
  link: String
  message: String!
  status: CnameCheckStatus!
}

enum CnameCheckStatus {
  ERROR
  INFO
  INVALID
  VALID
  WAITING
}

type Container implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  environment: Environment!
  environmentId: String!
  id: ID!
  migratedAt: DateTime
  plugin: Plugin!
  pluginId: String!
}

type Credit implements Node {
  amount: Float!
  createdAt: DateTime!
  customerId: String!
  id: ID!
  memo: String
  type: CreditType!
  updatedAt: DateTime!
}

enum CreditType {
  APPLIED
  CREDIT
  DEBIT
  STRIPE
  TRANSFER
  WAIVED
}

type CustomDomain implements Domain {
  cnameCheck: CnameCheck! @deprecated(reason: "Use the `status` field instead.")
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  edgeId: String
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  status: CustomDomainStatus!
  targetPort: Int
  updatedAt: DateTime
}

input CustomDomainCreateInput {
  domain: String!
  environmentId: String!
  projectId: String!
  serviceId: String!
  targetPort: Int
}

type CustomDomainStatus {
  cdnProvider: CDNProvider
  certificateStatus: CertificateStatus!
  certificates: [CertificatePublicData!]
  dnsRecords: [DNSRecords!]!
}

type Customer implements Node {
  """
  The total amount of credits that have been applied during the current billing period.
  """
  appliedCredits: Float!
  billingEmail: String
  billingPeriod: BillingPeriod!

  """The total amount of unused credits for the customer."""
  creditBalance: Float!
  credits(after: String, before: String, first: Int, last: Int): CustomerCreditsConnection!

  """
  The current usage for the customer. This value is cached and may not be up to date.
  """
  currentUsage: Float!
  defaultPaymentMethod: PaymentMethod
  defaultPaymentMethodId: String
  hasExhaustedFreePlan: Boolean!
  id: ID!
  invoices: [CustomerInvoice!]!
  isPrepaying: Boolean!
  isTrialing: Boolean!
  isUsageSubscriber: Boolean!
  isWithdrawingToCredits: Boolean!
  planLimitOverride: PlanLimitOverride
  remainingUsageCreditBalance: Float!
  state: SubscriptionState!
  stripeCustomerId: String!
  subscriptions: [CustomerSubscription!]!
  trialDaysRemaining: Int!
  usageLimit: UsageLimit
  workspace: Workspace!
}

type CustomerCreditsConnection {
  edges: [CustomerCreditsConnectionEdge!]!
  pageInfo: PageInfo!
}

type CustomerCreditsConnectionEdge {
  cursor: String!
  node: Credit!
}

type CustomerInvoice {
  amountDue: Float!
  amountPaid: Float!
  hostedURL: String
  invoiceId: String!
  items: [SubscriptionItem!]!
  paymentIntentStatus: String
  pdfURL: String
  periodEnd: String!
  periodStart: String!
  reissuedInvoiceFrom: String
  reissuedInvoiceOf: String
  status: String
  subscriptionId: String
  total: Int!
}

type CustomerSubscription {
  billingCycleAnchor: DateTime!
  cancelAt: String
  cancelAtPeriodEnd: Boolean!
  couponId: String
  discounts: [SubscriptionDiscount!]!
  id: String!
  items: [SubscriptionItem!]!
  latestInvoiceId: String!
  nextInvoiceCurrentTotal: Int!
  nextInvoiceDate: String!
  status: String!
}

enum DNSRecordPurpose {
  DNS_RECORD_PURPOSE_ACME_DNS01_CHALLENGE
  DNS_RECORD_PURPOSE_TRAFFIC_ROUTE
  DNS_RECORD_PURPOSE_UNSPECIFIED
  UNRECOGNIZED
}

enum DNSRecordStatus {
  DNS_RECORD_STATUS_PROPAGATED
  DNS_RECORD_STATUS_REQUIRES_UPDATE
  DNS_RECORD_STATUS_UNSPECIFIED
  UNRECOGNIZED
}

enum DNSRecordType {
  DNS_RECORD_TYPE_A
  DNS_RECORD_TYPE_CNAME
  DNS_RECORD_TYPE_NS
  DNS_RECORD_TYPE_UNSPECIFIED
  UNRECOGNIZED
}

type DNSRecords {
  currentValue: String!
  fqdn: String!
  hostlabel: String!
  purpose: DNSRecordPurpose!
  recordType: DNSRecordType!
  requiredValue: String!
  status: DNSRecordStatus!
  zone: String!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Deployment implements Node {
  canRedeploy: Boolean!
  canRollback: Boolean!
  createdAt: DateTime!
  creator: DeploymentCreator

  """Check if a deployment's instances have all stopped"""
  deploymentStopped: Boolean!
  environment: Environment!
  environmentId: String!
  id: ID!
  instances: [DeploymentDeploymentInstance!]!
  meta: DeploymentMeta
  projectId: String!
  service: Service!
  serviceId: String
  snapshotId: String
  sockets: [DeploymentSocket!]!
  staticUrl: String
  status: DeploymentStatus!
  statusUpdatedAt: DateTime
  suggestAddServiceDomain: Boolean!
  updatedAt: DateTime!
  url: String
}

type DeploymentCreator {
  avatar: String
  email: String!
  id: String!
  name: String
}

type DeploymentDeploymentInstance {
  status: DeploymentInstanceStatus!
}

type DeploymentEvent implements Node {
  completedAt: DateTime
  createdAt: DateTime!
  id: ID!
  payload: DeploymentEventPayload
  step: DeploymentEventStep!
}

type DeploymentEventPayload {
  error: String
}

enum DeploymentEventStep {
  BUILD_IMAGE
  CREATE_CONTAINER
  DRAIN_INSTANCES
  HEALTHCHECK
  MIGRATE_VOLUMES
  PRE_DEPLOY_COMMAND
  PUBLISH_IMAGE
  SNAPSHOT_CODE
  WAIT_FOR_DEPENDENCIES
}

type DeploymentInstanceExecution implements Node {
  completedAt: DateTime
  createdAt: DateTime!
  deploymentId: String!
  deploymentMeta: DeploymentMeta!
  id: ID!
  status: DeploymentInstanceStatus!
  updatedAt: DateTime!
}

input DeploymentInstanceExecutionCreateInput {
  serviceInstanceId: String!
}

input DeploymentInstanceExecutionInput {
  deploymentId: String!
}

input DeploymentInstanceExecutionListInput {
  environmentId: String!
  serviceId: String!
}

enum DeploymentInstanceStatus {
  CRASHED
  CREATED
  EXITED
  INITIALIZING
  REMOVED
  REMOVING
  RESTARTING
  RUNNING
  SKIPPED
  STOPPED
}

input DeploymentListInput {
  environmentId: String
  includeDeleted: Boolean
  projectId: String
  serviceId: String
  status: DeploymentStatusInput
}

scalar DeploymentMeta

type DeploymentSnapshot implements Node {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  variables: EnvironmentVariables!
}

type DeploymentSocket {
  ipv6: Boolean!
  port: Int!
  processName: String!
  updatedAt: Int!
}

enum DeploymentStatus {
  BUILDING
  CRASHED
  DEPLOYING
  FAILED
  INITIALIZING
  NEEDS_APPROVAL
  QUEUED
  REMOVED
  REMOVING
  SKIPPED
  SLEEPING
  SUCCESS
  WAITING
}

input DeploymentStatusInput {
  in: [DeploymentStatus!]
  notIn: [DeploymentStatus!]
}

type DeploymentTrigger implements Node {
  baseEnvironmentOverrideId: String
  branch: String!
  checkSuites: Boolean!
  environmentId: String!
  id: ID!
  projectId: String!
  provider: String!
  repository: String!
  serviceId: String
  validCheckSuites: Int!
}

input DeploymentTriggerCreateInput {
  branch: String!
  checkSuites: Boolean
  environmentId: String!
  projectId: String!
  provider: String!
  repository: String!
  rootDirectory: String
  serviceId: String!
}

input DeploymentTriggerUpdateInput {
  branch: String
  checkSuites: Boolean
  repository: String
  rootDirectory: String
}

scalar DisplayConfig

type DockerComposeImport {
  errors: [String!]!
  patch: EnvironmentConfig
}

interface Domain {
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  edgeId: String
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  targetPort: Int
  updatedAt: DateTime
}

type DomainAvailable {
  available: Boolean!
  message: String!
}

type DomainWithStatus {
  cdnProvider: CDNProvider
  certificateStatus: CertificateStatus!
  certificates: [CertificatePublicData!]
  dnsRecords: [DNSRecords!]!
  domain: Domain
}

type EgressGateway {
  ipv4: String!
  region: String!
}

input EgressGatewayCreateInput {
  environmentId: String!
  region: String
  serviceId: String!
}

input EgressGatewayServiceTargetInput {
  environmentId: String!
  serviceId: String!
}

type Environment implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deploymentTriggers(after: String, before: String, first: Int, last: Int): EnvironmentDeploymentTriggersConnection!
  deployments(after: String, before: String, first: Int, last: Int): EnvironmentDeploymentsConnection!
  id: ID!
  isEphemeral: Boolean!
  meta: EnvironmentMeta
  name: String!
  projectId: String!
  serviceInstances(after: String, before: String, first: Int, last: Int): EnvironmentServiceInstancesConnection!
  sourceEnvironment: Environment
  unmergedChangesCount: Int
  updatedAt: DateTime!
  variables(after: String, before: String, first: Int, last: Int): EnvironmentVariablesConnection!
  volumeInstances(after: String, before: String, first: Int, last: Int): EnvironmentVolumeInstancesConnection!
}

scalar EnvironmentConfig

input EnvironmentCreateInput {
  """
  If true, the changes will be applied in the background and the mutation will return immediately. If false, the mutation will wait for the changes to be applied before returning.
  """
  applyChangesInBackground: Boolean
  ephemeral: Boolean
  name: String!
  projectId: String!

  """When committing the changes immediately, skip any initial deployments."""
  skipInitialDeploys: Boolean

  """
  Create the environment with all of the services, volumes, configuration, and variables from this source environment.
  """
  sourceEnvironmentId: String

  """
  Stage the initial changes for the environment. If false (default), the changes will be committed immediately.
  """
  stageInitialChanges: Boolean
}

type EnvironmentDeploymentTriggersConnection {
  edges: [EnvironmentDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type EnvironmentDeploymentsConnection {
  edges: [EnvironmentDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type EnvironmentMeta {
  baseBranch: String
  branch: String
  prCommentId: Int
  prNumber: Int
  prRepo: String
  prTitle: String
}

input EnvironmentRenameInput {
  name: String!
}

type EnvironmentServiceInstancesConnection {
  edges: [EnvironmentServiceInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentServiceInstancesConnectionEdge {
  cursor: String!
  node: ServiceInstance!
}

input EnvironmentTriggersDeployInput {
  environmentId: String!
  projectId: String!
  serviceId: String!
}

"""
EnvironmentVariables is a custom scalar type that represents a map of environment variables.
"""
scalar EnvironmentVariables

type EnvironmentVariablesConnection {
  edges: [EnvironmentVariablesConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentVariablesConnectionEdge {
  cursor: String!
  node: Variable!
}

type EnvironmentVolumeInstancesConnection {
  edges: [EnvironmentVolumeInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type EnvironmentVolumeInstancesConnectionEdge {
  cursor: String!
  node: VolumeInstance!
}

"""The estimated usage of a single measurement."""
type EstimatedUsage {
  """The estimated value."""
  estimatedValue: Float!

  """The measurement that was estimated."""
  measurement: MetricMeasurement!
  projectId: String!
}

type Event implements Node {
  action: String!
  createdAt: DateTime!
  environment: Environment
  environmentId: String
  id: ID!
  object: String!
  payload: JSON
  project: Project!
  projectId: String!
}

input EventFilterInput {
  action: EventStringListFilter
  object: EventStringListFilter
}

input EventStringListFilter {
  in: [String!]
  notIn: [String!]
}

input ExplicitOwnerInput {
  """The ID of the owner"""
  id: String!

  """The type of owner"""
  type: ResourceOwnerType
}

type ExternalWorkspace {
  avatar: String
  banReason: String
  createdAt: DateTime!
  customerId: String
  customerState: SubscriptionState!
  discordRole: String
  hasBAA: Boolean!
  id: String!
  isTrialing: Boolean
  name: String!
  preferredRegion: String
  projects: [Project!]!
  subscriptionModel: SubscriptionModel!
  supportTierOverride: String
  teamId: String
}

input FeatureFlagToggleInput {
  flag: ActiveFeatureFlag!
}

type FunctionRuntime {
  """The image of the function runtime"""
  image: String!

  """The latest version of the function runtime"""
  latestVersion: FunctionRuntimeVersion!

  """The name of the function runtime"""
  name: FunctionRuntimeName!

  """The versions of the function runtime"""
  versions: [FunctionRuntimeVersion!]!
}

"""Supported function runtime environments"""
enum FunctionRuntimeName {
  bun
}

type FunctionRuntimeVersion {
  image: String!
  tag: String!
}

type GitHubAccess {
  hasAccess: Boolean!
  isPublic: Boolean!
}

type GitHubBranch {
  name: String!
}

type GitHubRepo {
  defaultBranch: String!
  description: String
  fullName: String!
  id: Int!
  installationId: String!
  isPrivate: Boolean!
  name: String!
  ownerAvatarUrl: String
}

input GitHubRepoDeployInput {
  branch: String
  projectId: String!
  repo: String!
}

input GitHubRepoUpdateInput {
  environmentId: String!
  projectId: String!
  serviceId: String!
}

type GitHubRepoWithoutInstallation {
  defaultBranch: String!
  description: String
  fullName: String!
  id: Int!
  isPrivate: Boolean!
  name: String!
}

type HerokuApp {
  id: String!
  name: String!
}

input HerokuImportVariablesInput {
  environmentId: String!
  herokuAppId: String!
  projectId: String!
  serviceId: String!
}

"""The result of a http logs query."""
type HttpLog {
  """The client user agent"""
  clientUa: String!

  """The deployment ID that was requested"""
  deploymentId: String!

  """The deployment instance ID that was requested"""
  deploymentInstanceId: String!

  """The downstream HTTP protocol version"""
  downstreamProto: String!

  """The edge region the client connected to"""
  edgeRegion: String!

  """The requested host"""
  host: String!

  """The http status of the log"""
  httpStatus: Int!

  """The request HTTP method"""
  method: String!

  """The requested path"""
  path: String!

  """The unique request ID"""
  requestId: String!

  """Details about the upstream response"""
  responseDetails: String!

  """Received bytes"""
  rxBytes: Int!

  """The source IP of the request"""
  srcIp: String!

  """The timestamp the log was created"""
  timestamp: String!

  """The total duration the request took"""
  totalDuration: Int!

  """Outgoing bytes"""
  txBytes: Int!

  """The upstream address"""
  upstreamAddress: String!

  """The upstream HTTP protocol version"""
  upstreamProto: String!

  """How long the upstream request took to respond"""
  upstreamRqDuration: Int!
}

type Incident {
  id: String!
  message: String!
  status: IncidentStatus!
  url: String!
}

enum IncidentStatus {
  IDENTIFIED
  INVESTIGATING
  MONITORING
  RESOLVED
}

type Integration implements Node {
  config: JSON!
  id: ID!
  name: String!
  projectId: String!
}

type IntegrationAuth implements Node {
  id: ID!
  integrations(after: String, before: String, first: Int, last: Int): IntegrationAuthIntegrationsConnection!
  provider: String!
  providerId: String!
}

type IntegrationAuthIntegrationsConnection {
  edges: [IntegrationAuthIntegrationsConnectionEdge!]!
  pageInfo: PageInfo!
}

type IntegrationAuthIntegrationsConnectionEdge {
  cursor: String!
  node: Integration!
}

input IntegrationCreateInput {
  config: JSON!
  integrationAuthId: String
  name: String!
  projectId: String!
}

input IntegrationUpdateInput {
  config: JSON!
  integrationAuthId: String
  name: String!
  projectId: String!
}

type InviteCode implements Node {
  code: String!
  createdAt: DateTime!
  id: ID!
  project: Project!
  projectId: String!
  role: ProjectRole!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input JobApplicationCreateInput {
  email: String!
  jobId: String!
  name: String!
  why: String!
}

enum KeyType {
  KEY_TYPE_ECDSA
  KEY_TYPE_RSA_2048
  KEY_TYPE_RSA_4096
  KEY_TYPE_UNSPECIFIED
  UNRECOGNIZED
}

"""The result of a logs query."""
type Log {
  """The attributes that were parsed from a structured log"""
  attributes: [LogAttribute!]!

  """The contents of the log message"""
  message: String!

  """The severity of the log message (eg. err)"""
  severity: String

  """The tags that were associated with the log"""
  tags: LogTags

  """The timestamp of the log message in format RFC3339 (nano)"""
  timestamp: String!
}

"""The attributes associated with a structured log"""
type LogAttribute {
  key: String!
  value: String!
}

"""The tags associated with a specific log"""
type LogTags {
  deploymentId: String
  deploymentInstanceId: String
  environmentId: String
  pluginId: String
  projectId: String
  serviceId: String
  snapshotId: String
}

input LoginSessionAuthInput {
  code: String!
  hostname: String
}

type Maintenance {
  id: String!
  message: String!
  status: MaintenanceStatus!
  url: String!
}

enum MaintenanceStatus {
  COMPLETED
  INPROGRESS
  NOTSTARTEDYET
}

"""A single sample of a metric."""
type Metric {
  """
  The timestamp of the sample. Represented has number of seconds since the Unix epoch.
  """
  ts: Int!

  """The value of the sample."""
  value: Float!
}

"""A thing that can be measured on Railway."""
enum MetricMeasurement {
  BACKUP_USAGE_GB
  CPU_LIMIT
  CPU_USAGE
  CPU_USAGE_2
  DISK_USAGE_GB
  EPHEMERAL_DISK_USAGE_GB
  MEASUREMENT_UNSPECIFIED
  MEMORY_LIMIT_GB
  MEMORY_USAGE_GB
  NETWORK_RX_GB
  NETWORK_TX_GB
  UNRECOGNIZED
}

"""A property that can be used to group metrics."""
enum MetricTag {
  DEPLOYMENT_ID
  DEPLOYMENT_INSTANCE_ID
  ENVIRONMENT_ID
  HOST_TYPE
  KEY_UNSPECIFIED
  PLUGIN_ID
  PROJECT_ID
  SERVICE_ID
  UNRECOGNIZED
  VOLUME_ID
  VOLUME_INSTANCE_ID
}

"""The tags that were used to group the metric."""
type MetricTags {
  deploymentId: String
  environmentId: String
  pluginId: String
  projectId: String
  serviceId: String
  volumeId: String
  volumeInstanceId: String
}

"""The result of a metrics query."""
type MetricsResult {
  """The measurement of the metric."""
  measurement: MetricMeasurement!

  """
  The tags that were used to group the metric. Only the tags that were used to by will be present.
  """
  tags: MetricTags!

  """The samples of the metric."""
  values: [Metric!]!
}

enum MonitorAlertResourceType {
  SERVICE
  VOLUME
}

enum MonitorStatus {
  ALERT
  OK
}

enum MonitorThresholdCondition {
  above
  below
}

type MonitorThresholdConfig {
  condition: MonitorThresholdCondition!
  measurement: MetricMeasurement
  threshold: Float!
  type: String!
}

type Mutation {
  """Creates a new API token."""
  apiTokenCreate(input: ApiTokenCreateInput!): String!

  """Deletes an API token."""
  apiTokenDelete(id: String!): Boolean!

  """Sets the base environment override for a deployment trigger."""
  baseEnvironmentOverride(id: String!, input: BaseEnvironmentOverrideInput!): Boolean!

  """Creates a new custom domain."""
  customDomainCreate(input: CustomDomainCreateInput!): CustomDomain!

  """Deletes a custom domain."""
  customDomainDelete(id: String!): Boolean!

  """Updates a custom domain."""
  customDomainUpdate(environmentId: String!, id: String!, targetPort: Int): Boolean!

  """Create a free plan subscription for a customer"""
  customerCreateFreePlanSubscription(id: String!): Boolean!

  """Toggle whether a customer is automatically withdrawing to credits"""
  customerTogglePayoutsToCredits(customerId: String!, input: customerTogglePayoutsToCreditsInput!): Boolean!

  """Approves a deployment."""
  deploymentApprove(id: String!): Boolean!

  """Cancels a deployment."""
  deploymentCancel(id: String!): Boolean!

  """Invoke a deployment instance execution."""
  deploymentInstanceExecutionCreate(input: DeploymentInstanceExecutionCreateInput!): Boolean!

  """Redeploys a deployment."""
  deploymentRedeploy(id: String!, usePreviousImageTag: Boolean): Deployment!

  """Removes a deployment."""
  deploymentRemove(id: String!): Boolean!

  """Restarts a deployment."""
  deploymentRestart(id: String!): Boolean!

  """Rolls back to a deployment."""
  deploymentRollback(id: String!): Boolean!

  """Stops a deployment."""
  deploymentStop(id: String!): Boolean!

  """Creates a deployment trigger."""
  deploymentTriggerCreate(input: DeploymentTriggerCreateInput!): DeploymentTrigger!

  """Deletes a deployment trigger."""
  deploymentTriggerDelete(id: String!): Boolean!

  """Updates a deployment trigger."""
  deploymentTriggerUpdate(id: String!, input: DeploymentTriggerUpdateInput!): DeploymentTrigger!

  """Create services and volumes from docker compose"""
  dockerComposeImport(environmentId: String!, projectId: String!, skipStagingPatch: Boolean, yaml: String!): DockerComposeImport!

  """Create a new egress gateway association for a service instance"""
  egressGatewayAssociationCreate(input: EgressGatewayCreateInput!): [EgressGateway!]!

  """Clear all egress gateway associations for a service instance"""
  egressGatewayAssociationsClear(input: EgressGatewayServiceTargetInput!): Boolean!

  """
  Change the User's account email if there is a valid change email request.
  """
  emailChangeConfirm(nonce: String!): Boolean!

  """Initiate an email change request for a user"""
  emailChangeInitiate(newEmail: String!): Boolean!

  """Creates a new environment."""
  environmentCreate(input: EnvironmentCreateInput!): Environment!

  """Deletes an environment."""
  environmentDelete(id: String!): Boolean!

  """Commit the provided patch to the environment."""
  environmentPatchCommit(commitMessage: String, environmentId: String!, patch: EnvironmentConfig): String!

  """Renames an environment."""
  environmentRename(id: String!, input: EnvironmentRenameInput!): Environment!

  """Deploys all connected triggers for an environment."""
  environmentTriggersDeploy(input: EnvironmentTriggersDeployInput!): Boolean!

  """Agree to the fair use policy for the currently authenticated user"""
  fairUseAgree(agree: Boolean!): Boolean!

  """Add a feature flag for a user"""
  featureFlagAdd(input: FeatureFlagToggleInput!): Boolean!

  """Remove a feature flag for a user"""
  featureFlagRemove(input: FeatureFlagToggleInput!): Boolean!

  """Deploys a GitHub repo"""
  githubRepoDeploy(input: GitHubRepoDeployInput!): String!

  """Updates a GitHub repo through the linked template"""
  githubRepoUpdate(input: GitHubRepoUpdateInput!): Boolean!

  """
  Import variables from a Heroku app into a Railway service. Returns the number of variables imports
  """
  herokuImportVariables(input: HerokuImportVariablesInput!): Int!

  """Create an integration for a project"""
  integrationCreate(input: IntegrationCreateInput!): Integration!

  """Delete an integration for a project"""
  integrationDelete(id: String!): Boolean!

  """Update an integration for a project"""
  integrationUpdate(id: String!, input: IntegrationUpdateInput!): Integration!

  """Join a project using an invite code"""
  inviteCodeUse(code: String!): Project!

  """Creates a new job application."""
  jobApplicationCreate(input: JobApplicationCreateInput!, resume: Upload!): Boolean!

  """Auth a login session for a user"""
  loginSessionAuth(input: LoginSessionAuthInput!): Boolean!

  """Cancel a login session"""
  loginSessionCancel(code: String!): Boolean!

  """Get a token for a login session if it exists"""
  loginSessionConsume(code: String!): String

  """Start a CLI login session"""
  loginSessionCreate: String!

  """Verify if a login session is valid"""
  loginSessionVerify(code: String!): Boolean!

  """Deletes session for current user if it exists"""
  logout: Boolean!

  """Create an observability dashboard"""
  observabilityDashboardCreate(input: ObservabilityDashboardCreateInput!): Boolean!

  """Reset an observability dashboard to default dashboard items"""
  observabilityDashboardReset(id: String!): Boolean!

  """Update an observability dashboard"""
  observabilityDashboardUpdate(id: String!, input: [ObservabilityDashboardUpdateInput!]!): Boolean!

  """Creates a new plugin."""
  pluginCreate(input: PluginCreateInput!): Plugin! @deprecated(reason: "Plugins are deprecated on Railway. Use database templates instead.")

  """Deletes a plugin."""
  pluginDelete(environmentId: String, id: String!): Boolean!

  """Reset envs and container for a plugin in an environment"""
  pluginReset(id: String!, input: ResetPluginInput!): Boolean!

  """Resets the credentials for a plugin in an environment"""
  pluginResetCredentials(id: String!, input: ResetPluginCredentialsInput!): String!

  """Restarts a plugin."""
  pluginRestart(id: String!, input: PluginRestartInput!): Plugin!

  """Force start a plugin"""
  pluginStart(id: String!, input: PluginRestartInput!): Boolean!

  """Updates an existing plugin."""
  pluginUpdate(id: String!, input: PluginUpdateInput!): Plugin!

  """
  Create/Updates preferences overrides for a specific resource belonging to a user
  """
  preferenceOverridesCreateUpdate(input: PreferenceOverridesCreateUpdateData!): Boolean!

  """
  Destroy preferences overrides for a specific resource belonging to a user
  """
  preferenceOverridesDestroyForResource(input: PreferenceOverridesDestroyData!): Boolean!

  """Update the email preferences for a user"""
  preferencesUpdate(input: PreferencesUpdateData!): Preferences!

  """Create or get a private network."""
  privateNetworkCreateOrGet(input: PrivateNetworkCreateOrGetInput!): PrivateNetwork!

  """Create or get a private network endpoint."""
  privateNetworkEndpointCreateOrGet(input: PrivateNetworkEndpointCreateOrGetInput!): PrivateNetworkEndpoint!

  """Delete a private network endpoint."""
  privateNetworkEndpointDelete(id: String!): Boolean!

  """Rename a private network endpoint."""
  privateNetworkEndpointRename(dnsName: String!, id: String!, privateNetworkId: String!): Boolean!

  """Delete all private networks for an environment."""
  privateNetworksForEnvironmentDelete(environmentId: String!): Boolean!

  """Claims a project."""
  projectClaim(id: String!, workspaceId: String!): Project!

  """Creates a new project."""
  projectCreate(input: ProjectCreateInput!): Project!

  """Deletes a project."""
  projectDelete(id: String!): Boolean!

  """Accept a project invitation using the invite code"""
  projectInvitationAccept(code: String!): ProjectPermission!

  """Create an invitation for a project"""
  projectInvitationCreate(id: String!, input: ProjectInvitee!): ProjectInvitation!

  """Delete an invitation for a project"""
  projectInvitationDelete(id: String!): Boolean!

  """Resend an invitation for a project"""
  projectInvitationResend(id: String!): ProjectInvitation!

  """Invite a user by email to a project"""
  projectInviteUser(id: String!, input: ProjectInviteUserInput!): Boolean!

  """Leave project as currently authenticated user"""
  projectLeave(id: String!): Boolean!

  """Remove user from a project"""
  projectMemberRemove(input: ProjectMemberRemoveInput!): [ProjectMember!]!

  """Change the role for a user within a project"""
  projectMemberUpdate(input: ProjectMemberUpdateInput!): ProjectMember!

  """Deletes a project with a 48 hour grace period."""
  projectScheduleDelete(id: String!): Boolean!

  """Cancel scheduled deletion of a project"""
  projectScheduleDeleteCancel(id: String!): Boolean!

  """
  Force delete a scheduled deletion of a project (skips the grace period)
  """
  projectScheduleDeleteForce(id: String!): Boolean!

  """Create a token for a project that has access to a specific environment"""
  projectTokenCreate(input: ProjectTokenCreateInput!): String!

  """Delete a project token"""
  projectTokenDelete(id: String!): Boolean!

  """Confirm the transfer of project ownership"""
  projectTransferConfirm(input: ProjectTransferConfirmInput!): Boolean!

  """Initiate the transfer of project ownership"""
  projectTransferInitiate(input: ProjectTransferInitiateInput!): Boolean!

  """Transfer a project to a team"""
  projectTransferToTeam(id: String!, input: ProjectTransferToTeamInput!): Boolean!

  """Updates a project."""
  projectUpdate(id: String!, input: ProjectUpdateInput!): Project!

  """Deletes a ProviderAuth."""
  providerAuthRemove(id: String!): Boolean!

  """Generates a new set of recovery codes for the authenticated user."""
  recoveryCodeGenerate: RecoveryCodes!

  """Validates a recovery code."""
  recoveryCodeValidate(input: RecoveryCodeValidateInput!): Boolean!

  """Updates the ReferralInfo for the authenticated user."""
  referralInfoUpdate(input: ReferralInfoUpdateInput!): ReferralInfo!

  """Send a notification email to user when bounty is won"""
  sendBountyWonEmail(input: SendBountyWonEmailInput!): Boolean!

  """Send a community thread notification email"""
  sendCommunityThreadNotificationEmail(input: SendCommunityThreadNotificationEmailInput!): Boolean!

  """Send an email to welcome a user to our community"""
  sendCommunityWelcomeEmail(input: SendCommunityWelcomeEmailInput!): Boolean!

  """Send a new bounty question email"""
  sendNewBountyEmail(input: SendNewBountyEmailInput!): Boolean!

  """Send a question moved to bounty email"""
  sendQuestionMovedToBountyEmail(input: SendQuestionMovedToBountyEmailInput!): Boolean!

  """Connect a service to a source"""
  serviceConnect(id: String!, input: ServiceConnectInput!): Service!

  """Creates a new service."""
  serviceCreate(input: ServiceCreateInput!): Service!

  """Deletes a service."""
  serviceDelete(
    """
    [Experimental] Environment ID. If the environment is a forked environment, the service will only be deleted in the specified environment, otherwise it will deleted in all environments that are not forks of other environments
    """
    environmentId: String
    id: String!
  ): Boolean!

  """Disconnect a service from a repo"""
  serviceDisconnect(id: String!): Service!

  """Creates a new service domain."""
  serviceDomainCreate(input: ServiceDomainCreateInput!): ServiceDomain!

  """Deletes a service domain."""
  serviceDomainDelete(id: String!): Boolean!

  """Updates a service domain."""
  serviceDomainUpdate(input: ServiceDomainUpdateInput!): Boolean!

  """
  Duplicate a service, including its configuration, variables, and volumes.
  """
  serviceDuplicate(environmentId: String!, serviceId: String!): Service! @deprecated(reason: "This API route is used only by the CLI. We plan to remove it in a future version. Please use the UI to duplicate services.")

  """Add a feature flag for a service"""
  serviceFeatureFlagAdd(input: ServiceFeatureFlagToggleInput!): Boolean!

  """Remove a feature flag for a service"""
  serviceFeatureFlagRemove(input: ServiceFeatureFlagToggleInput!): Boolean!

  """Deploy a service instance"""
  serviceInstanceDeploy(commitSha: String, environmentId: String!, latestCommit: Boolean, serviceId: String!): Boolean!

  """Deploy a service instance. Returns a deployment ID"""
  serviceInstanceDeployV2(commitSha: String, environmentId: String!, serviceId: String!): String!

  """Update the resource limits for a service instance"""
  serviceInstanceLimitsUpdate(input: ServiceInstanceLimitsUpdateInput!): Boolean!

  """Redeploy a service instance"""
  serviceInstanceRedeploy(environmentId: String!, serviceId: String!): Boolean!

  """Update a service instance"""
  serviceInstanceUpdate(
    """
    [Experimental] Environment ID. If the environment is a fork, the service will only be updated in it. Otherwise it will updated in all environments that are not forks of other environments
    """
    environmentId: String
    input: ServiceInstanceUpdateInput!
    serviceId: String!
  ): Boolean!

  """Remove the upstream URL from all service instances for this service"""
  serviceRemoveUpstreamUrl(id: String!): Service!

  """Updates a service."""
  serviceUpdate(id: String!, input: ServiceUpdateInput!): Service!

  """Deletes a session."""
  sessionDelete(id: String!): Boolean!

  """Configure a shared variable."""
  sharedVariableConfigure(input: SharedVariableConfigureInput!): Variable!

  """Creates a new TCP proxy for a service instance."""
  tcpProxyCreate(input: TCPProxyCreateInput!): TCPProxy! @deprecated(reason: "Use staged changes and apply them. Creating a TCP proxy with this endpoint requires you to redeploy the service for it to be active.")

  """Deletes a TCP proxy by id"""
  tcpProxyDelete(id: String!): Boolean!

  """Bulk transfer projects from user to team"""
  teamBulkProjectTransfer(input: TeamBulkProjectTransferInput!): Boolean!

  """Create a team and subscribe to the Pro plan"""
  teamCreateAndSubscribe(input: TeamCreateAndSubscribeInput!): TeamCreateAndSubscribeResponse!

  """Get an invite code for a team and role"""
  teamInviteCodeCreate(id: String!, input: TeamInviteCodeCreateInput!): String!

  """Use an invite code to join a team"""
  teamInviteCodeUse(code: String!): Team!

  """Leave a team"""
  teamLeave(id: String!): Boolean!

  """Changes a user team permissions."""
  teamPermissionChange(input: TeamPermissionChangeInput!): Boolean!

  """Create a new team trusted domain for this team"""
  teamTrustedDomainCreate(input: TeamTrustedDomainCreateInput!): Boolean!

  """Delete a team trusted domain"""
  teamTrustedDomainDelete(id: String!): Boolean!

  """Invite a user by email to a team"""
  teamUserInvite(id: String!, input: TeamUserInviteInput!): Boolean!

  """Remove a user from a team"""
  teamUserRemove(id: String!, input: TeamUserRemoveInput!): Boolean!

  """Duplicates an existing template"""
  templateClone(input: TemplateCloneInput!): Template!

  """Deletes a template."""
  templateDelete(id: String!, input: TemplateDeleteInput!): Boolean!

  """Deploys a template."""
  templateDeploy(input: TemplateDeployInput!): TemplateDeployPayload! @deprecated(reason: "Deprecated in favor of templateDeployV2")

  """Deploys a template using the serialized template config"""
  templateDeployV2(input: TemplateDeployV2Input!): TemplateDeployPayload!

  """Generate a template for a project"""
  templateGenerate(input: TemplateGenerateInput!): Template!

  """
  Nullify the community thread slug for a template, if one is found with the provided slug
  """
  templateMaybeUnsetCommunityThreadSlug(communityThreadSlug: String!): Boolean!

  """Publishes a template."""
  templatePublish(id: String!, input: TemplatePublishInput!): Template!

  """
  Ejects a service from the template and creates a new repo in the provided org.
  """
  templateServiceSourceEject(input: TemplateServiceSourceEjectInput!): Boolean!

  """Unpublishes a template."""
  templateUnpublish(id: String!): Boolean!

  """Setup 2FA authorization for authenticated user."""
  twoFactorInfoCreate(input: TwoFactorInfoCreateInput!): RecoveryCodes!

  """Deletes the TwoFactorInfo for the authenticated user."""
  twoFactorInfoDelete: Boolean!

  """Generates the 2FA app secret for the authenticated user."""
  twoFactorInfoSecret: TwoFactorInfoSecret!

  """Validates the token for a 2FA action or for a login request."""
  twoFactorInfoValidate(input: TwoFactorInfoValidateInput!): Boolean!

  """Generate a Slack channel for a team"""
  upsertSlackChannelForTeam(teamId: String!): Boolean!

  """Remove the usage limit for a customer"""
  usageLimitRemove(input: UsageLimitRemoveInput!): Boolean!

  """Set the usage limit for a customer"""
  usageLimitSet(input: UsageLimitSetInput!): Boolean!

  """Unsubscribe from the Beta program."""
  userBetaLeave: Boolean!

  """Delete the currently authenticated user"""
  userDelete: Boolean!

  """Disconnect your Railway account from Discord."""
  userDiscordDisconnect: Boolean!

  """Remove a flag on the user."""
  userFlagsRemove(input: UserFlagsRemoveInput!): Boolean!

  """Set flags on the authenticated user."""
  userFlagsSet(input: UserFlagsSetInput!): Boolean!

  """Updates the profile for the authenticated user"""
  userProfileUpdate(input: UserProfileUpdateInput!): Boolean!

  """Disconnect your Railway account from Slack."""
  userSlackDisconnect: Boolean!

  """Update date of TermsAgreedOn"""
  userTermsUpdate: User

  """Update currently logged in user"""
  userUpdate(input: UserUpdateInput!): User

  """Upserts a collection of variables."""
  variableCollectionUpsert(input: VariableCollectionUpsertInput!): Boolean!

  """Deletes a variable."""
  variableDelete(input: VariableDeleteInput!): Boolean!

  """Upserts a variable."""
  variableUpsert(input: VariableUpsertInput!): Boolean!

  """Create a persistent volume in a project"""
  volumeCreate(input: VolumeCreateInput!): Volume!

  """Delete a persistent volume in a project"""
  volumeDelete(volumeId: String!): Boolean!

  """Create backup of a volume instance"""
  volumeInstanceBackupCreate(
    """The id of the volume instance to create a backup of"""
    volumeInstanceId: String!
  ): WorkflowId!

  """Deletes volume instance backup"""
  volumeInstanceBackupDelete(
    """The volume instance's backup id"""
    volumeInstanceBackupId: String!

    """The volume instance's id"""
    volumeInstanceId: String!
  ): WorkflowId!

  """Removes backup expiration date"""
  volumeInstanceBackupLock(
    """The id of the backup to lock"""
    volumeInstanceBackupId: String!

    """The id of the volume instance to be restored from"""
    volumeInstanceId: String!
  ): Boolean!

  """Restore a volume instance from a backup"""
  volumeInstanceBackupRestore(
    """The id of the backup to be restored from"""
    volumeInstanceBackupId: String!

    """The id of the volume instance to be restored from"""
    volumeInstanceId: String!
  ): WorkflowId!

  """Manage schedule for backups of a volume instance"""
  volumeInstanceBackupScheduleUpdate(
    """The frequency/retention of the backups"""
    kinds: [VolumeInstanceBackupScheduleKind!]!

    """The id of the volume instance to create a backup of"""
    volumeInstanceId: String!
  ): Boolean!

  """
  Update a volume instance. If no environmentId is provided, all volume instances for the volume will be updated.
  """
  volumeInstanceUpdate(
    """
    The environment of the volume instance to update. If null, all instances for the volume will be updated
    """
    environmentId: String
    input: VolumeInstanceUpdateInput!

    """The id of the volume to update"""
    volumeId: String!
  ): Boolean!

  """Update a persistent volume in a project"""
  volumeUpdate(input: VolumeUpdateInput!, volumeId: String!): Volume!

  """Create a webhook on a project"""
  webhookCreate(input: WebhookCreateInput!): ProjectWebhook!

  """Delete a webhook from a project"""
  webhookDelete(id: String!): Boolean!

  """Update a webhook on a project"""
  webhookUpdate(id: String!, input: WebhookUpdateInput!): ProjectWebhook!

  """Delete a workspace and all data associated with it"""
  workspaceDelete(id: String!): Boolean!

  """Leave a workspace"""
  workspaceLeave(id: String!): Boolean!

  """Update a workspace by id"""
  workspaceUpdate(id: String!, input: WorkspaceUpdateInput!): Boolean!

  """Generate a Slack channel for a workspace"""
  workspaceUpsertSlackChannel(id: String!): Boolean!
}

interface Node {
  id: ID!
}

type ObservabilityDashboard implements Node {
  id: ID!
  items: [ObservabilityDashboardItemInstance!]!
}

type ObservabilityDashboardAlert implements Node {
  createdAt: DateTime!
  id: ID!
  resolvedAt: DateTime
  resourceId: String
  resourceType: MonitorAlertResourceType!
  status: MonitorStatus!
}

input ObservabilityDashboardCreateInput {
  environmentId: String!

  """If no items are provided, a default dashboard will be created."""
  items: [ObservabilityDashboardUpdateInput!]
}

type ObservabilityDashboardItem implements Node {
  config: ObservabilityDashboardItemConfig!
  description: String
  id: ID!
  monitors: [ObservabilityDashboardMonitor!]!
  name: String!
  type: ObservabilityDashboardItemType!
}

type ObservabilityDashboardItemConfig {
  logsFilter: String
  measurements: [MetricMeasurement!]
  projectUsageProperties: [ProjectUsageProperty!]
  resourceIds: [String!]
}

input ObservabilityDashboardItemConfigInput {
  logsFilter: String
  measurements: [MetricMeasurement!]
  projectUsageProperties: [ProjectUsageProperty!]
  resourceIds: [String!]
}

input ObservabilityDashboardItemCreateInput {
  config: ObservabilityDashboardItemConfigInput!
  description: String
  id: String!
  name: String!
  type: ObservabilityDashboardItemType!
}

type ObservabilityDashboardItemInstance implements Node {
  dashboardItem: ObservabilityDashboardItem!
  displayConfig: DisplayConfig!
  id: ID!
}

enum ObservabilityDashboardItemType {
  PROJECT_USAGE_ITEM
  SERVICE_LOGS_ITEM
  SERVICE_METRICS_ITEM
  VOLUME_METRICS_ITEM
}

type ObservabilityDashboardMonitor implements Node {
  alerts(endDate: DateTime, startDate: DateTime): [ObservabilityDashboardAlert!]!
  config: ObservabilityDashboardMonitorConfig!
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

union ObservabilityDashboardMonitorConfig = MonitorThresholdConfig

input ObservabilityDashboardUpdateInput {
  dashboardItem: ObservabilityDashboardItemCreateInput!
  displayConfig: DisplayConfig!
  id: String!
}

input OverrideInput {
  enabled: Boolean!
  name: String!
  resource: String!
  resourceId: String!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PaymentMethod {
  card: PaymentMethodCard
  id: String!
}

type PaymentMethodCard {
  brand: String!
  country: String
  last4: String!
}

type PlanLimitOverride implements Node {
  config: SubscriptionPlanLimit!
  id: ID!
}

enum PlatformFeatureFlag {
  COMPRESS_VOLUME_MIGRATION
  DEFAULT_NEW_USERS_RAILPACK
  DEMO_PERCENTAGE_ROLLOUT
  ENABLE_METAL_REGISTRY_AMS
  ENABLE_METAL_REGISTRY_DC4
  ENABLE_METAL_REGISTRY_GCP_REGIONS
  ENABLE_METAL_REGISTRY_SG3
  ENABLE_METAL_REGISTRY_SV2
  NON_DESTRUCTIVE_VOLUME_MIGRATIONS
  REFERRAL_CASH
  RESUMABLE_VOLUME_MIGRATION
  UPDATED_VM_QUERIES
}

type PlatformFeatureFlagStatus {
  flag: PlatformFeatureFlag!
  rolloutPercentage: Int!
  status: Boolean!
  type: PlatformFeatureFlagType!
}

enum PlatformFeatureFlagType {
  BOOLEAN
  PERCENTAGE
}

type PlatformStatus {
  incident: Incident
  isStable: Boolean!
  maintenance: Maintenance
}

type Plugin implements Node {
  containers(after: String, before: String, first: Int, last: Int): PluginContainersConnection!
  createdAt: DateTime!
  deletedAt: DateTime
  deprecatedAt: DateTime
  friendlyName: String!
  id: ID!
  logsEnabled: Boolean!
  migrationDatabaseServiceId: String
  name: PluginType!
  project: Project!
  status: PluginStatus!
  variables(after: String, before: String, first: Int, last: Int): PluginVariablesConnection!
}

type PluginContainersConnection {
  edges: [PluginContainersConnectionEdge!]!
  pageInfo: PageInfo!
}

type PluginContainersConnectionEdge {
  cursor: String!
  node: Container!
}

input PluginCreateInput {
  environmentId: String
  friendlyName: String
  name: String!
  projectId: String!
}

input PluginRestartInput {
  environmentId: String
}

enum PluginStatus {
  DEPRECATED
  LOCKED
  REMOVED
  RUNNING
  STOPPED
}

enum PluginType {
  mongodb
  mysql
  postgresql
  redis
}

input PluginUpdateInput {
  friendlyName: String!
}

type PluginVariablesConnection {
  edges: [PluginVariablesConnectionEdge!]!
  pageInfo: PageInfo!
}

type PluginVariablesConnectionEdge {
  cursor: String!
  node: Variable!
}

type PreferenceOverride implements Node {
  enabled: Boolean!
  id: ID!
  name: String!
  resource: String!
  resourceId: String!
}

input PreferenceOverridesCreateUpdateData {
  overrides: [OverrideInput!]!
}

input PreferenceOverridesDestroyData {
  resource: String!
  resourceId: String!
}

type Preferences implements Node {
  buildFailedEmail: Boolean!
  changelogEmail: Boolean!
  communityEmail: Boolean!
  deployCrashedEmail: Boolean!
  ephemeralEnvironmentEmail: Boolean!
  id: ID!
  marketingEmail: Boolean!
  preferenceOverrides: [PreferenceOverride!]
  subprocessorUpdatesEmail: Boolean!
  usageEmail: Boolean!
}

input PreferencesUpdateData {
  buildFailedEmail: Boolean
  changelogEmail: Boolean
  communityEmail: Boolean
  deployCrashedEmail: Boolean
  ephemeralEnvironmentEmail: Boolean
  marketingEmail: Boolean
  subprocessorUpdatesEmail: Boolean
  token: String
  usageEmail: Boolean
}

type PrivateNetwork {
  createdAt: DateTime
  deletedAt: DateTime
  dnsName: String!
  environmentId: String!
  name: String!
  networkId: BigInt!
  projectId: String!
  publicId: String!
  tags: [String!]!
}

input PrivateNetworkCreateOrGetInput {
  environmentId: String!
  name: String!
  projectId: String!
  tags: [String!]!
}

type PrivateNetworkEndpoint {
  createdAt: DateTime
  deletedAt: DateTime
  dnsName: String!
  privateIps: [String!]!
  publicId: String!
  serviceInstanceId: String!
  tags: [String!]!
}

input PrivateNetworkEndpointCreateOrGetInput {
  environmentId: String!
  privateNetworkId: String!
  serviceId: String!
  serviceName: String!
  tags: [String!]!
}

type Project implements Node {
  baseEnvironment: Environment
  baseEnvironmentId: String
  botPrEnvironments: Boolean!
  createdAt: DateTime!
  deletedAt: DateTime
  deploymentTriggers(after: String, before: String, first: Int, last: Int): ProjectDeploymentTriggersConnection!
  deployments(after: String, before: String, first: Int, last: Int): ProjectDeploymentsConnection!
  description: String
  environments(after: String, before: String, first: Int, last: Int): ProjectEnvironmentsConnection!
  expiredAt: DateTime
  groups(after: String, before: String, first: Int, last: Int): ProjectGroupsConnection!
  id: ID!
  isPublic: Boolean!
  isTempProject: Boolean!
  members: [ProjectMember!]!
  name: String!
  plugins(after: String, before: String, first: Int, last: Int): ProjectPluginsConnection!
  prDeploys: Boolean!
  projectPermissions(after: String, before: String, first: Int, last: Int): ProjectProjectPermissionsConnection!
  services(after: String, before: String, first: Int, last: Int): ProjectServicesConnection!
  subscriptionPlanLimit: SubscriptionPlanLimit!
  subscriptionType: SubscriptionPlanType!
  team: Team
  teamId: String
  updatedAt: DateTime!
  volumes(after: String, before: String, first: Int, last: Int): ProjectVolumesConnection!
  webhooks(after: String, before: String, first: Int, last: Int): ProjectWebhooksConnection!
}

input ProjectCreateInput {
  defaultEnvironmentName: String
  description: String
  isPublic: Boolean
  name: String
  prDeploys: Boolean
  repo: ProjectCreateRepo
  runtime: PublicRuntime
  teamId: String
}

input ProjectCreateRepo {
  branch: String!
  fullRepoName: String!
}

type ProjectDeploymentTriggersConnection {
  edges: [ProjectDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type ProjectDeploymentsConnection {
  edges: [ProjectDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type ProjectEnvironmentsConnection {
  edges: [ProjectEnvironmentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectEnvironmentsConnectionEdge {
  cursor: String!
  node: Environment!
}

type ProjectGroupsConnection {
  edges: [ProjectGroupsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectGroupsConnectionEdge {
  cursor: String!
}

type ProjectInvitation {
  email: String!
  expiresAt: DateTime!
  id: ID!
  inviter: ProjectInvitationInviter
  isExpired: Boolean!
  project: PublicProjectInformation!
}

type ProjectInvitationInviter {
  email: String!
  name: String
}

input ProjectInviteUserInput {
  email: String!
  link: String!
}

input ProjectInvitee {
  email: String!
  role: ProjectRole!
}

type ProjectMember {
  avatar: String
  email: String!
  id: String!
  name: String
  role: ProjectRole!
}

input ProjectMemberRemoveInput {
  projectId: String!
  userId: String!
}

input ProjectMemberUpdateInput {
  projectId: String!
  role: ProjectRole!
  userId: String!
}

type ProjectPermission implements Node {
  id: ID!
  projectId: String!
  role: ProjectRole!
  userId: String!
}

type ProjectPluginsConnection {
  edges: [ProjectPluginsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectPluginsConnectionEdge {
  cursor: String!
  node: Plugin!
}

type ProjectProjectPermissionsConnection {
  edges: [ProjectProjectPermissionsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectProjectPermissionsConnectionEdge {
  cursor: String!
  node: ProjectPermission!
}

type ProjectResourceAccess {
  customDomain: AccessRule!
  databaseDeployment: AccessRule!
  deployment: AccessRule!
  environment: AccessRule!
  plugin: AccessRule!
}

enum ProjectRole {
  ADMIN
  MEMBER
  VIEWER
}

type ProjectServicesConnection {
  edges: [ProjectServicesConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectServicesConnectionEdge {
  cursor: String!
  node: Service!
}

type ProjectToken implements Node {
  createdAt: DateTime!
  displayToken: String!
  environment: Environment!
  environmentId: String!
  id: ID!
  name: String!
  project: Project!
  projectId: String!
}

input ProjectTokenCreateInput {
  environmentId: String!
  name: String!
  projectId: String!
}

input ProjectTransferConfirmInput {
  destinationWorkspaceId: String
  ownershipTransferId: String!
  projectId: String!
}

input ProjectTransferInitiateInput {
  memberId: String!
  projectId: String!
}

input ProjectTransferToTeamInput {
  teamId: String!
}

input ProjectUpdateInput {
  baseEnvironmentId: String

  """Enable/disable pull request environments for PRs created by bots"""
  botPrEnvironments: Boolean
  description: String
  isPublic: Boolean
  name: String
  prDeploys: Boolean
}

enum ProjectUsageProperty {
  BACKUP_USAGE
  CPU_USAGE
  CURRENT_USAGE
  DISK_USAGE
  ESTIMATED_USAGE
  MEMORY_USAGE
  NETWORK_USAGE
}

type ProjectVolumesConnection {
  edges: [ProjectVolumesConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectVolumesConnectionEdge {
  cursor: String!
  node: Volume!
}

type ProjectWebhook implements Node {
  filters: [String!]
  id: ID!
  lastStatus: Int
  projectId: String!
  url: String!
}

type ProjectWebhooksConnection {
  edges: [ProjectWebhooksConnectionEdge!]!
  pageInfo: PageInfo!
}

type ProjectWebhooksConnectionEdge {
  cursor: String!
  node: ProjectWebhook!
}

type ProviderAuth implements Node {
  email: String!
  id: ID!
  metadata: JSON!
  provider: String!
  userId: String!
}

type PublicProjectInformation {
  id: ID!
  name: String!
}

union PublicProjectInvitation = InviteCode | ProjectInvitation

enum PublicRuntime {
  LEGACY
  UNSPECIFIED
  V2
}

type PublicStats {
  totalDeploymentsLastMonth: Int!
  totalLogsLastMonth: BigInt!
  totalProjects: Int!
  totalRequestsLastMonth: BigInt!
  totalServices: Int!
  totalUsers: Int!
}

type Query {
  """Get all volume instances for a given volume"""
  adminVolumeInstancesForVolume(volumeId: String!): [VolumeInstance!]!

  """Returns the platform feature flags enabled for the current user"""
  allPlatformFeatureFlags: [PlatformFeatureFlagStatus!]!

  """Gets all API tokens for the authenticated user."""
  apiTokens(after: String, before: String, first: Int, last: Int): QueryApiTokensConnection!

  """Fetch logs for a build"""
  buildLogs(
    deploymentId: String!
    endDate: DateTime

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    startDate: DateTime
  ): [Log!]!

  """Gets the image URL for a Notion image block"""
  changelogBlockImage(id: String!): String!

  """Fetch details for a custom domain"""
  customDomain(id: String!, projectId: String!): CustomDomain!

  """Checks if a custom domain is available."""
  customDomainAvailable(domain: String!): DomainAvailable!

  """Find a single deployment"""
  deployment(id: String!): Deployment!

  """Get the deployment events for a deployment"""
  deploymentEvents(after: String, before: String, first: Int, id: String!, last: Int): QueryDeploymentEventsConnection!

  """Get the deployment instance executions for a deployment."""
  deploymentInstanceExecutions(after: String, before: String, first: Int, input: DeploymentInstanceExecutionListInput!, last: Int): QueryDeploymentInstanceExecutionsConnection!

  """Fetch logs for a deployment"""
  deploymentLogs(
    deploymentId: String!
    endDate: DateTime

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    startDate: DateTime
  ): [Log!]!

  """Find a single DeploymentSnapshot"""
  deploymentSnapshot(deploymentId: String!): DeploymentSnapshot

  """All deployment triggers."""
  deploymentTriggers(after: String, before: String, environmentId: String!, first: Int, last: Int, projectId: String!, serviceId: String!): QueryDeploymentTriggersConnection!

  """Get all deployments"""
  deployments(after: String, before: String, first: Int, input: DeploymentListInput!, last: Int): QueryDeploymentsConnection!

  """Domain with status"""
  domainStatus(id: String!, projectId: String!): DomainWithStatus! @deprecated(reason: "Use the `status` field within the `domain` query instead")

  """All domains for a service instance"""
  domains(environmentId: String!, projectId: String!, serviceId: String!): AllDomains!

  """All egress gateways assigned to a service instance"""
  egressGateways(environmentId: String!, serviceId: String!): [EgressGateway!]!

  """Find a single environment"""
  environment(id: String!): Environment!

  """
  Fetch logs for a project environment. Build logs are excluded unless a snapshot ID is explicitly provided in the filter
  """
  environmentLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    environmentId: String!

    """Filter logs using a query syntax"""
    filter: String
  ): [Log!]!

  """Get the patches for an environment"""
  environmentPatches(after: String, before: String, environmentId: String!, first: Int, last: Int): QueryEnvironmentPatchesConnection!

  """Gets all environments for a project."""
  environments(after: String, before: String, first: Int, isEphemeral: Boolean, last: Int, projectId: String!): QueryEnvironmentsConnection!

  """
  Get the estimated total cost of the project at the end of the current billing cycle. If no `startDate` is provided, the usage for the current billing period of the project owner is returned.
  """
  estimatedUsage(
    """Whether to include deleted projects in estimations."""
    includeDeleted: Boolean
    measurements: [MetricMeasurement!]!
    projectId: String
    teamId: String
  ): [EstimatedUsage!]!

  """Gets the events for a project."""
  events(after: String, before: String, environmentId: String, filter: EventFilterInput, first: Int, last: Int, projectId: String!): QueryEventsConnection!

  """
  Get the workspaces the user doesn't belong to, but needs access (like when invited to a project)
  """
  externalWorkspaces(projectId: String): [ExternalWorkspace!]!

  """Get information about a specific function runtime"""
  functionRuntime(name: FunctionRuntimeName!): FunctionRuntime!

  """List available function runtimes"""
  functionRuntimes: [FunctionRuntime!]!

  """Checks if user has access to GitHub repository"""
  gitHubRepoAccessAvailable(fullRepoName: String!): GitHubAccess!

  """Check if a repo name is available"""
  githubIsRepoNameAvailable(fullRepoName: String!): Boolean!

  """Checks if user has access to GitHub repository"""
  githubRepo(fullRepoName: String!): GitHubRepoWithoutInstallation!

  """
  Get branches for a GitHub repo that the authenticated user has access to
  """
  githubRepoBranches(owner: String!, repo: String!): [GitHubBranch!]!

  """Get a list of repos for a user that Railway has access to"""
  githubRepos: [GitHubRepo!]!

  """Get a list of scopes the user has installed the installation to"""
  githubWritableScopes: [String!]!

  """Get the Herokus apps for the current user"""
  herokuApps: [HerokuApp!]!

  """Fetch HTTP logs for a deployment"""
  httpLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    deploymentId: String!
    endDate: String

    """Filter logs using a query syntax"""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    startDate: String
  ): [HttpLog!]!

  """Get an integration auth by provider providerId"""
  integrationAuth(provider: String!, providerId: String!): IntegrationAuth!

  """Get all integration auths for a user"""
  integrationAuths(after: String, before: String, first: Int, last: Int): QueryIntegrationAuthsConnection!

  """Get all integrations for a project"""
  integrations(after: String, before: String, first: Int, last: Int, projectId: String!): QueryIntegrationsConnection!

  """Get an invite code by the code"""
  inviteCode(code: String!): InviteCode!

  """Gets the authenticated user."""
  me: User!

  """Get metrics for a project, environment, and service"""
  metrics(
    """
    The averaging window when computing CPU usage. By default, it is the same as the `sampleRateSeconds`.
    """
    averagingWindowSeconds: Int

    """
    The end of the period to get metrics for. If not provided, the current datetime is used.
    """
    endDate: DateTime
    environmentId: String

    """
    What to group the aggregated usage by. By default, it is grouped over the entire project.
    """
    groupBy: [MetricTag!]

    """Whether or not to include deleted projects in the results"""
    includeDeleted: Boolean
    measurements: [MetricMeasurement!]!
    pluginId: String
    projectId: String

    """
    The frequency of data points in the response. If the `sampleRateSeconds` is 60, then the response will contain one data point per minute.
    """
    sampleRateSeconds: Int
    serviceId: String

    """The start of the period to get metrics for."""
    startDate: DateTime!
    teamId: String
    volumeId: String
    volumeInstanceExternalId: String
    workspaceId: String
  ): [MetricsResult!]!

  """"""
  node(id: ID!): Node

  """"""
  nodes(ids: [ID!]!): [Node]!

  """Get all observability dashboards for an environment"""
  observabilityDashboards(after: String, before: String, environmentId: String!, first: Int, last: Int): QueryObservabilityDashboardsConnection!

  """Get the current status of the platform"""
  platformStatus: PlatformStatus!

  """Get a plugin by ID."""
  plugin(id: String!): Plugin!

  """Fetch logs for a plugin"""
  pluginLogs(
    endDate: DateTime
    environmentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    pluginId: String!
    startDate: DateTime
  ): [Log!]!

  """Get the email preferences for a user"""
  preferences(token: String): Preferences!

  """Get a private network endpoint for a service instance."""
  privateNetworkEndpoint(environmentId: String!, privateNetworkId: String!, serviceId: String!): PrivateNetworkEndpoint

  """Check if an endpoint name is available."""
  privateNetworkEndpointNameAvailable(environmentId: String!, prefix: String!, privateNetworkId: String!): Boolean!

  """List private networks for an environment."""
  privateNetworks(environmentId: String!): [PrivateNetwork!]!

  """Get a project by ID"""
  project(id: String!): Project!

  """Get a project invitation by code"""
  projectInvitation(code: String!): PublicProjectInvitation!

  """Get invitations for a project"""
  projectInvitations(id: String!): [ProjectInvitation!]!

  """Get an invite code for a project for a specifc role"""
  projectInviteCode(projectId: String!, role: ProjectRole!): InviteCode!

  """Gets users who belong to a project along with their role"""
  projectMembers(projectId: String!): [ProjectMember!]!

  """Get resource access rules for project-specific actions"""
  projectResourceAccess(projectId: String!): ProjectResourceAccess!

  """Get a single project token by the value in the header"""
  projectToken: ProjectToken!

  """Get all project tokens for a project"""
  projectTokens(after: String, before: String, first: Int, last: Int, projectId: String!): QueryProjectTokensConnection!

  """Gets all projects for a user or a team."""
  projects(after: String, before: String, first: Int, includeDeleted: Boolean, last: Int, teamId: String, userId: String): QueryProjectsConnection!

  """Get public Railway stats."""
  publicStats: PublicStats!

  """Gets the ReferralInfo for the authenticated user."""
  referralInfo(workspaceId: String!): ReferralInfo!

  """List available regions"""
  regions(projectId: String): [Region!]!

  """Get resource access for the current user or team"""
  resourceAccess(explicitResourceOwner: ExplicitOwnerInput!): ResourceAccess!

  """Get a service by ID"""
  service(id: String!): Service!

  """Checks if a service domain is available"""
  serviceDomainAvailable(domain: String!): DomainAvailable!

  """Get a service instance belonging to a service and environment"""
  serviceInstance(environmentId: String!, serviceId: String!): ServiceInstance!

  """Check if the upstream repo for a service has an update available"""
  serviceInstanceIsUpdatable(environmentId: String!, serviceId: String!): Boolean!

  """
  Get the service instance resource limit overrides (null if no overrides set)
  """
  serviceInstanceLimitOverride(environmentId: String!, serviceId: String!): ServiceInstanceLimit

  """
  Get the merged resource limits for a service instance (includes plan defaults)
  """
  serviceInstanceLimits(environmentId: String!, projectId: String!, serviceId: String!): ServiceInstanceLimit!

  """Gets all sessions for authenticated user."""
  sessions(after: String, before: String, first: Int, last: Int): QuerySessionsConnection!

  """All TCP proxies for a service instance"""
  tcpProxies(environmentId: String!, serviceId: String!): [TCPProxy!]!

  """Find a team by ID"""
  team(id: String!): Team!

  """Find a team by invite code"""
  teamByCode(code: String!): Team!

  """Get all templates for a team."""
  teamTemplates(after: String, before: String, first: Int, last: Int, teamId: String!): QueryTeamTemplatesConnection!

  """Get all team trusted domains"""
  teamTrustedDomains(after: String, before: String, first: Int, last: Int, teamId: String!): QueryTeamTrustedDomainsConnection!

  """Get a template by code or GitHub owner and repo."""
  template(code: String, owner: String, repo: String): Template!

  """Get the source template for a project."""
  templateSourceForProject(projectId: String!): Template

  """Get all published templates."""
  templates(
    after: String
    before: String
    first: Int
    last: Int

    """If set to true, only recommended templates will be returned."""
    recommended: Boolean
  ): QueryTemplatesConnection!

  """Count all published templates."""
  templatesCount: Int!

  """Gets the TwoFactorInfo for the authenticated user."""
  twoFactorInfo: TwoFactorInfo!

  """
  Get the usage for a single project or all projects for a user/team. If no `projectId` or `teamId` is provided, the usage for the current user is returned. If no `startDate` is provided, the usage for the current billing period of the project owner is returned.
  """
  usage(
    endDate: DateTime

    """
    What to group the aggregated usage by. By default, it is grouped over the entire project.
    """
    groupBy: [MetricTag!]

    """Whether to include deleted projects in the usage."""
    includeDeleted: Boolean
    measurements: [MetricMeasurement!]!
    projectId: String
    startDate: DateTime
    teamId: String
  ): [AggregatedUsage!]!

  """Get the user id corresponding to a Discord id"""
  userIdForDiscordId(discordId: String!): String!

  """Get the user id corresponding to a Slack id"""
  userIdForSlackId(slackId: String!): String

  """Get the total kickback earnings for a user."""
  userKickbackEarnings(userId: String!): UserKickbackEarnings! @deprecated(reason: "This field is deprecated and will be removed in future versions.")

  """Get the public profile for a user"""
  userProfile(username: String!): UserProfileResponse!

  """Get all templates for the current user."""
  userTemplates(after: String, before: String, first: Int, last: Int): QueryUserTemplatesConnection! @deprecated(reason: "Users don't have personal templates anymore, they belong to their team now")

  """
  All variables by pluginId or serviceId. If neither are provided, all shared variables are returned.
  """
  variables(
    environmentId: String!

    """Provide a pluginId to get all variables for a specific plugin."""
    pluginId: String
    projectId: String!

    """Provide a serviceId to get all variables for a specific service."""
    serviceId: String
    unrendered: Boolean
  ): EnvironmentVariables!

  """All rendered variables that are required for a service deployment."""
  variablesForServiceDeployment(environmentId: String!, projectId: String!, serviceId: String!): EnvironmentVariables!

  """Get information about the user's Vercel accounts"""
  vercelInfo: VercelInfo!

  """Get a single volume instance by id"""
  volumeInstance(id: String!): VolumeInstance!

  """List backups of a volume instance"""
  volumeInstanceBackupList(
    """The id of the volume instance to list the backups of"""
    volumeInstanceId: String!
  ): [VolumeInstanceBackup!]!

  """List backups schedules of a volume instance"""
  volumeInstanceBackupScheduleList(
    """The id of the volume instance to list the schedules of"""
    volumeInstanceId: String!
  ): [VolumeInstanceBackupSchedule!]!

  """Get all webhooks for a project"""
  webhooks(after: String, before: String, first: Int, last: Int, projectId: String!): QueryWebhooksConnection!

  """Gets the status of a workflow"""
  workflowStatus(workflowId: String!): WorkflowResult!

  """Get the workspace"""
  workspace(workspaceId: String!): Workspace!
}

type QueryApiTokensConnection {
  edges: [QueryApiTokensConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryApiTokensConnectionEdge {
  cursor: String!
  node: ApiToken!
}

type QueryDeploymentEventsConnection {
  edges: [QueryDeploymentEventsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentEventsConnectionEdge {
  cursor: String!
  node: DeploymentEvent!
}

type QueryDeploymentInstanceExecutionsConnection {
  edges: [QueryDeploymentInstanceExecutionsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentInstanceExecutionsConnectionEdge {
  cursor: String!
  node: DeploymentInstanceExecution!
}

type QueryDeploymentTriggersConnection {
  edges: [QueryDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type QueryDeploymentsConnection {
  edges: [QueryDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type QueryEnvironmentPatchesConnection {
  edges: [QueryEnvironmentPatchesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryEnvironmentPatchesConnectionEdge {
  cursor: String!
}

type QueryEnvironmentsConnection {
  edges: [QueryEnvironmentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryEnvironmentsConnectionEdge {
  cursor: String!
  node: Environment!
}

type QueryEventsConnection {
  edges: [QueryEventsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryEventsConnectionEdge {
  cursor: String!
  node: Event!
}

type QueryIntegrationAuthsConnection {
  edges: [QueryIntegrationAuthsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryIntegrationAuthsConnectionEdge {
  cursor: String!
  node: IntegrationAuth!
}

type QueryIntegrationsConnection {
  edges: [QueryIntegrationsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryIntegrationsConnectionEdge {
  cursor: String!
  node: Integration!
}

type QueryObservabilityDashboardsConnection {
  edges: [QueryObservabilityDashboardsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryObservabilityDashboardsConnectionEdge {
  cursor: String!
  node: ObservabilityDashboard!
}

type QueryProjectTokensConnection {
  edges: [QueryProjectTokensConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryProjectTokensConnectionEdge {
  cursor: String!
  node: ProjectToken!
}

type QueryProjectsConnection {
  edges: [QueryProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

type QuerySessionsConnection {
  edges: [QuerySessionsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QuerySessionsConnectionEdge {
  cursor: String!
  node: Session!
}

type QueryTeamTemplatesConnection {
  edges: [QueryTeamTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryTeamTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

type QueryTeamTrustedDomainsConnection {
  edges: [QueryTeamTrustedDomainsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryTeamTrustedDomainsConnectionEdge {
  cursor: String!
  node: TeamTrustedDomain!
}

type QueryTemplatesConnection {
  edges: [QueryTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

type QueryUserTemplatesConnection {
  edges: [QueryUserTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryUserTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}

type QueryWebhooksConnection {
  edges: [QueryWebhooksConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryWebhooksConnectionEdge {
  cursor: String!
  node: ProjectWebhook!
}

scalar RailpackInfo

input RecoveryCodeValidateInput {
  code: String!
  twoFactorLinkingKey: String
}

type RecoveryCodes {
  recoveryCodes: [String!]!
}

type ReferralInfo implements Node {
  code: String!
  id: ID!
  referralStats: ReferralStats!
  status: String!
}

input ReferralInfoUpdateInput {
  code: String!
  workspaceId: String!
}

type ReferralStats {
  credited: Int!
  pending: Int!
}

enum ReferralStatus {
  REFEREE_CREDITED
  REFERRER_CREDITED
  REGISTERED
}

type ReferralUser {
  code: String!
  id: String!
  status: ReferralStatus!
}

type RefundRequest implements Node {
  amount: Int!
  decision: RefundRequestDecisionEnum
  id: ID!
  invoiceId: String!
  plainThreadId: String
  reason: String!
  userId: String
  workspace: Workspace!
}

"""Possible decisions for a RefundRequest"""
enum RefundRequestDecisionEnum {
  AUTO_REFUNDED
  AUTO_REJECTED
  MANUALLY_REFUNDED
}

type Region {
  """Region country"""
  country: String!
  deploymentConstraints: RegionDeploymentConstraints
  location: String!
  name: String!

  """Region is on Railway Metal"""
  railwayMetal: Boolean
  region: String
  teamId: String
}

type RegionDeploymentConstraints {
  """Admin only region"""
  adminOnly: Boolean

  """Deprecation information for the region"""
  deprecationInfo: RegionDeprecationInfo
  runtimeExclusivity: [String!]

  """Staging only region"""
  stagingOnly: Boolean
}

type RegionDeprecationInfo {
  """Specifies if the region is deprecated"""
  isDeprecated: Boolean!

  """Replacement region for the deprecated region"""
  replacementRegion: String!
}

enum RegistrationStatus {
  ONBOARDED
  REGISTERED
  WAITLISTED
}

"""
Private Docker registry credentials. Only available for Pro plan deployments.
"""
input RegistryCredentialsInput {
  password: String!
  username: String!
}

type ReissuedInvoice implements Node {
  id: ID!
  originalInvoiceId: String!
  reissuedInvoiceId: String
  workspace: Workspace!
  workspaceId: String!
}

enum ReplicateVolumeInstanceSnapshotStatus {
  COMPLETED
  FAILED
  INITIATED
  TRANSFERRING
  UNRECOGNIZED
}

"""The status of a volume instance replication"""
enum ReplicateVolumeInstanceStatus {
  COMPLETED
  ERROR
  QUEUED
  TRANSFERRING_OFFLINE
  TRANSFERRING_ONLINE
}

input ResetPluginCredentialsInput {
  environmentId: String!
}

input ResetPluginInput {
  environmentId: String!
}

type ResourceAccess {
  deployment: AccessRule!
  project: AccessRule!
}

enum ResourceOwnerType {
  TEAM
}

enum RestartPolicyType {
  ALWAYS
  NEVER
  ON_FAILURE
}

input SendBountyWonEmailInput {
  bountyAmount: Float!
  threadTitle: String!
  threadUrl: String!
  userId: String!
  workspaceName: String!
}

input SendCommunityThreadNotificationEmailInput {
  postEntryContent: String
  threadTitle: String!
  threadUrl: String!
  userIds: [String!]!
}

input SendCommunityWelcomeEmailInput {
  userId: String!
}

input SendNewBountyEmailInput {
  threadTitle: String!
  threadUrl: String!
  userIds: [String!]!
}

input SendQuestionMovedToBountyEmailInput {
  threadTitle: String!
  threadUrl: String!
  userId: String!
}

scalar SerializedTemplateConfig

type Service implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deployments(after: String, before: String, first: Int, last: Int): ServiceDeploymentsConnection!
  featureFlags: [ActiveServiceFeatureFlag!]!
  icon: String
  id: ID!
  name: String!
  project: Project!
  projectId: String!
  repoTriggers(after: String, before: String, first: Int, last: Int): ServiceRepoTriggersConnection!
  serviceInstances(after: String, before: String, first: Int, last: Int): ServiceServiceInstancesConnection!
  templateServiceId: String
  templateThreadSlug: String
  updatedAt: DateTime!
}

input ServiceConnectInput {
  """The branch to connect to. e.g. 'main'"""
  branch: String

  """Name of the Dockerhub or GHCR image to connect this service to."""
  image: String

  """The full name of the repo to connect to. e.g. 'railwayapp/starters'"""
  repo: String
}

input ServiceCreateInput {
  branch: String

  """
  Environment ID. If the specified environment is a fork, the service will only be created in it. Otherwise it will created in all environments that are not forks of other environments
  """
  environmentId: String
  icon: String
  name: String
  projectId: String!
  registryCredentials: RegistryCredentialsInput
  source: ServiceSourceInput
  templateServiceId: String
  variables: EnvironmentVariables
}

type ServiceDeploymentsConnection {
  edges: [ServiceDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}

type ServiceDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}

type ServiceDomain implements Domain {
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  edgeId: String
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  suffix: String
  targetPort: Int
  updatedAt: DateTime
}

input ServiceDomainCreateInput {
  environmentId: String!
  serviceId: String!
  targetPort: Int
}

input ServiceDomainUpdateInput {
  domain: String!
  environmentId: String!
  serviceDomainId: String
  serviceId: String!
  targetPort: Int
}

input ServiceFeatureFlagToggleInput {
  flag: ActiveServiceFeatureFlag!
  serviceId: String!
}

type ServiceInstance implements Node {
  buildCommand: String
  builder: Builder!
  createdAt: DateTime!
  cronSchedule: String
  deletedAt: DateTime
  domains: AllDomains!
  drainingSeconds: Int
  environmentId: String!
  healthcheckPath: String
  healthcheckTimeout: Int
  id: ID!
  isUpdatable: Boolean!
  latestDeployment: Deployment
  nextCronRunAt: DateTime
  nixpacksPlan: JSON
  numReplicas: Int
  overlapSeconds: Int
  preDeployCommand: JSON
  railpackInfo: RailpackInfo
  railwayConfigFile: String
  region: String
  restartPolicyMaxRetries: Int!
  restartPolicyType: RestartPolicyType!
  rootDirectory: String
  serviceId: String!
  serviceName: String!
  sleepApplication: Boolean
  source: ServiceSource
  startCommand: String
  updatedAt: DateTime!
  upstreamUrl: String
  watchPatterns: [String!]!
}

scalar ServiceInstanceLimit

input ServiceInstanceLimitsUpdateInput {
  environmentId: String!

  """Amount of memory in GB to allocate to the service instance"""
  memoryGB: Float
  serviceId: String!

  """Number of vCPUs to allocate to the service instance"""
  vCPUs: Float
}

input ServiceInstanceUpdateInput {
  buildCommand: String
  builder: Builder
  cronSchedule: String
  drainingSeconds: Int
  healthcheckPath: String
  healthcheckTimeout: Int
  multiRegionConfig: JSON
  nixpacksPlan: JSON
  numReplicas: Int
  overlapSeconds: Int
  preDeployCommand: [String!]
  railwayConfigFile: String
  region: String
  registryCredentials: RegistryCredentialsInput
  restartPolicyMaxRetries: Int
  restartPolicyType: RestartPolicyType
  rootDirectory: String
  sleepApplication: Boolean
  source: ServiceSourceInput
  startCommand: String
  watchPatterns: [String!]
}

type ServiceRepoTriggersConnection {
  edges: [ServiceRepoTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}

type ServiceRepoTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}

type ServiceServiceInstancesConnection {
  edges: [ServiceServiceInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type ServiceServiceInstancesConnectionEdge {
  cursor: String!
  node: ServiceInstance!
}

type ServiceSource {
  image: String
  repo: String
}

input ServiceSourceInput {
  image: String
  repo: String
}

input ServiceUpdateInput {
  icon: String
  name: String
}

type Session implements Node {
  createdAt: DateTime!
  expiredAt: DateTime!
  id: ID!
  isCurrent: Boolean!
  name: String!
  type: SessionType!
  updatedAt: DateTime!
}

enum SessionType {
  BROWSER
  CLI
  FORUMS
}

input SharedVariableConfigureInput {
  disabledServiceIds: [String!]!
  enabledServiceIds: [String!]!
  environmentId: String!
  name: String!
  projectId: String!
}

type SimilarTemplate {
  code: String!
  createdAt: DateTime!
  creator: TemplateCreator
  deploys: Int!
  description: String
  health: Float
  image: String
  name: String!
  teamId: String
  userId: String
}

type Subscription {
  """Stream logs for a build"""
  buildLogs(
    deploymentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
  ): [Log!]!

  """Subscribe to updates for a specific deployment"""
  deployment(id: String!): Deployment!

  """Subscribe to deployment events for a specific deployment"""
  deploymentEvents(id: String!): DeploymentEvent!

  """Subscribe to deployment instance executions for a specific deployment"""
  deploymentInstanceExecutions(input: DeploymentInstanceExecutionInput!): DeploymentInstanceExecution!

  """Stream logs for a deployment"""
  deploymentLogs(
    deploymentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
  ): [Log!]!

  """Stream logs for a project environment"""
  environmentLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    environmentId: String!

    """Filter logs using a query syntax"""
    filter: String
  ): [Log!]!

  """Stream HTTP logs for a deployment"""
  httpLogs(
    """Latest date to look for logs after the anchor"""
    afterDate: String

    """Limit the number of logs returned after the anchor"""
    afterLimit: Int

    """Target date time to look for logs"""
    anchorDate: String

    """Oldest date to look for logs before the anchor"""
    beforeDate: String

    """Limit the number of logs returned before the anchor"""
    beforeLimit: Int
    deploymentId: String!

    """Filter logs using a query syntax"""
    filter: String
  ): [HttpLog!]!

  """Stream logs for a plugin"""
  pluginLogs(
    environmentId: String!

    """Filter logs by a string. Providing an empty value will match all logs."""
    filter: String

    """Limit the number of logs returned (defaults 100, max 5000)"""
    limit: Int
    pluginId: String!
  ): [Log!]!

  """Subscribe to migration progress updates for a volume"""
  replicationProgress(volumeInstanceId: String!): VolumeReplicationProgressUpdate!
}

type SubscriptionDiscount {
  couponId: String!
}

type SubscriptionItem {
  itemId: String!
  priceId: String!
  productId: String!
  quantity: BigInt
}

enum SubscriptionModel {
  FREE
  TEAM
  USER
}

scalar SubscriptionPlanLimit

enum SubscriptionPlanType {
  free
  hobby
  pro
  trial
}

enum SubscriptionState {
  ACTIVE
  CANCELLED
  INACTIVE
  PAST_DUE
  UNPAID
}

enum SupportTierOverride {
  BUSINESS_CLASS
  BUSINESS_CLASS_TRIAL
}

type TCPProxy {
  applicationPort: Int!
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  environmentId: String!
  id: ID!
  proxyPort: Int!
  serviceId: String!
  updatedAt: DateTime
}

input TCPProxyCreateInput {
  applicationPort: Int!
  environmentId: String!
  serviceId: String!
}

type Team implements Node {
  adoptionHistory: [AdoptionInfo!]!
  adoptionLevel: Float!
  avatar: String @deprecated(reason: "This property is not part of Teams anymore, go through the Workspace to access it")
  createdAt: DateTime!
  customer: Customer! @deprecated(reason: "Access the customer through the workspace")
  id: ID!
  members: [TeamMember!]!
  name: String! @deprecated(reason: "This property is not part of Teams anymore, go through the Workspace to access it")
  preferredRegion: String @deprecated(reason: "This property is not part of Teams anymore, go through the Workspace to access it")
  projects(after: String, before: String, first: Int, last: Int): TeamProjectsConnection!
  slackChannelId: String @deprecated(reason: "This property is not part of Teams anymore, go through the Workspace to access it")
  supportTierOverride: SupportTierOverride @deprecated(reason: "This property is not part of Teams anymore, go through the Workspace to access it")
  teamPermissions: [TeamPermission!]!
  updatedAt: DateTime!
  workspace: Workspace!
}

input TeamBulkProjectTransferInput {
  projectIds: [String!]!
  teamId: String!
}

input TeamCreateAndSubscribeInput {
  avatar: String
  name: String!
  paymentMethodId: String!
}

type TeamCreateAndSubscribeResponse {
  customerId: String!
  paymentIntent: JSON
  teamId: String!
}

input TeamInviteCodeCreateInput {
  role: String!
}

type TeamMember {
  avatar: String
  email: String!

  """Only retrieved if requested by an admin"""
  featureFlags: [ActiveFeatureFlag!]
  id: String!
  name: String
  role: TeamRole!
}

type TeamPermission implements Node {
  createdAt: DateTime!
  id: ID!
  role: TeamRole!
  teamId: String!
  updatedAt: DateTime!
  userId: String!
}

input TeamPermissionChangeInput {
  role: TeamRole!
  teamId: String!
  userId: String!
}

type TeamProjectsConnection {
  edges: [TeamProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type TeamProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

enum TeamRole {
  ADMIN
  MEMBER
  VIEWER
}

type TeamTrustedDomain implements Node {
  domainName: String!
  id: ID!
  teamId: String!
  teamRole: String!
  verificationData: TrustedDomainVerificationData!
  verificationType: String!
}

input TeamTrustedDomainCreateInput {
  domainName: String!
  teamId: String!
  teamRole: String!
}

input TeamUserInviteInput {
  code: String!
  email: String!
}

input TeamUserRemoveInput {
  userId: String!
}

type Template implements Node {
  activeProjects: Int!
  canvasConfig: CanvasConfig
  category: String
  code: String!
  communityThreadSlug: String
  config: TemplateConfig!
  createdAt: DateTime!
  creator: TemplateCreator
  demoProjectId: String
  description: String
  guides: TemplateGuide
  health: Float
  id: ID!
  image: String
  isApproved: Boolean!
  isV2Template: Boolean!
  languages: [String!]
  metadata: TemplateMetadata! @deprecated(reason: "Deprecated in favor of listing the fields individually.")
  name: String!
  projects: Int!
  readme: String
  serializedConfig: SerializedTemplateConfig
  services(after: String, before: String, first: Int, last: Int): TemplateServicesConnection!
  similarTemplates: [SimilarTemplate!]!
  status: TemplateStatus!
  tags: [String!]
  teamId: String
  totalPayout: Float!
}

input TemplateCloneInput {
  code: String!
  teamId: String
}

scalar TemplateConfig

type TemplateCreator {
  avatar: String
  hasPublicProfile: Boolean!
  name: String
  username: String
}

input TemplateDeleteInput {
  teamId: String
}

input TemplateDeployInput {
  environmentId: String
  projectId: String
  services: [TemplateDeployService!]!
  teamId: String!
  templateCode: String
}

type TemplateDeployPayload {
  projectId: String!
  workflowId: String
}

input TemplateDeployService {
  commit: String
  hasDomain: Boolean
  healthcheckPath: String
  id: String!
  isPrivate: Boolean
  name: String
  owner: String
  preDeployCommand: [String!]
  rootDirectory: String
  serviceIcon: String
  serviceName: String!
  startCommand: String
  tcpProxyApplicationPort: Int
  template: String!
  variables: EnvironmentVariables
  volumes: [TemplateVolume!]
}

input TemplateDeployV2Input {
  environmentId: String
  projectId: String
  serializedConfig: SerializedTemplateConfig!
  teamId: String
  templateId: String!
}

input TemplateGenerateInput {
  environmentId: String
  projectId: String!
  teamId: String
}

type TemplateGuide {
  post: String
  video: String
}

scalar TemplateMetadata

input TemplatePublishInput {
  category: String!
  demoProjectId: String
  description: String!
  image: String
  readme: String!
  teamId: String
}

type TemplateService implements Node {
  config: TemplateServiceConfig!
  createdAt: DateTime!
  id: ID!
  templateId: String!
  updatedAt: DateTime!
}

scalar TemplateServiceConfig

input TemplateServiceSourceEjectInput {
  projectId: String!
  repoName: String!
  repoOwner: String!

  """Provide multiple serviceIds when ejecting services from a monorepo."""
  serviceIds: [String!]!
  upstreamUrl: String!
}

type TemplateServicesConnection {
  edges: [TemplateServicesConnectionEdge!]!
  pageInfo: PageInfo!
}

type TemplateServicesConnectionEdge {
  cursor: String!
  node: TemplateService!
}

enum TemplateStatus {
  HIDDEN
  PUBLISHED
  UNPUBLISHED
}

scalar TemplateVolume

type TrustedDomainVerificationData {
  domainMatch: Domain
  domainStatus: CustomDomainStatus
}

type TwoFactorInfo {
  hasRecoveryCodes: Boolean!
  isVerified: Boolean!
}

input TwoFactorInfoCreateInput {
  token: String!
}

type TwoFactorInfoSecret {
  secret: String!
  uri: String!
}

input TwoFactorInfoValidateInput {
  token: String!
  twoFactorLinkingKey: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UsageAnomaly implements Node {
  actedOn: DateTime
  action: UsageAnomalyAction
  actorId: String
  flaggedAt: DateTime!
  flaggedFor: UsageAnomalyFlagReason!
  id: ID!
}

"""Possible actions for a UsageAnomaly."""
enum UsageAnomalyAction {
  ALLOWED
  AUTOBANNED
  BANNED
}

"""Possible flag reasons for a UsageAnomaly."""
enum UsageAnomalyFlagReason {
  HIGH_CPU_USAGE
  HIGH_DISK_USAGE
  HIGH_NETWORK_USAGE
}

type UsageLimit implements Node {
  customerId: String!
  hardLimit: Int
  id: ID!
  isOverLimit: Boolean!
  softLimit: Int!
}

input UsageLimitRemoveInput {
  customerId: String!
}

input UsageLimitSetInput {
  customerId: String!
  hardLimitDollars: Int
  softLimitDollars: Int!
}

type User implements Node {
  agreedFairUse: Boolean!
  avatar: String
  banReason: String
  createdAt: DateTime!
  email: String!
  featureFlags: [ActiveFeatureFlag!]!
  flags: [UserFlag!]!
  has2FA: Boolean!
  id: ID!
  isAdmin: Boolean!
  isConductor: Boolean!
  isVerified: Boolean!
  lastLogin: DateTime!
  name: String
  platformFeatureFlags: [ActivePlatformFlag!]!
  profile: UserProfile
  projects(after: String, before: String, first: Int, last: Int): UserProjectsConnection! @deprecated(reason: "This field will not return anything anymore, go through the workspace's projects")
  providerAuths(after: String, before: String, first: Int, last: Int): UserProviderAuthsConnection!
  registrationStatus: RegistrationStatus!
  riskLevel: Float
  teams(after: String, before: String, first: Int, last: Int): UserTeamsConnection! @deprecated(reason: "Use the workspaces relation to access the teams")
  termsAgreedOn: DateTime
  username: String
  workspace: Workspace @deprecated(reason: "Use user.workspaces instead, no user are associated to a workspace")

  """Workspaces user is member of"""
  workspaces: [Workspace!]!
}

enum UserFlag {
  BETA
}

input UserFlagsRemoveInput {
  flags: [UserFlag!]!
  userId: String
}

input UserFlagsSetInput {
  flags: [UserFlag!]!
  userId: String
}

type UserKickbackEarnings {
  total_amount: Float!
}

type UserProfile {
  bio: String
  isPublic: Boolean!
  website: String
}

type UserProfileResponse {
  avatar: String
  createdAt: DateTime!
  customerId: String
  id: String!
  isTrialing: Boolean
  name: String
  profile: UserProfile!

  """Gets all public projects for a user."""
  publicProjects(after: String, before: String, first: Int, last: Int): UserProfileResponsePublicProjectsConnection!
  publishedTemplates: [SimilarTemplate!]! @deprecated(reason: "There are no personal templates anymore, they all belong to a workspace")
  state: String
  totalDeploys: Int!
  username: String
}

type UserProfileResponsePublicProjectsConnection {
  edges: [UserProfileResponsePublicProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserProfileResponsePublicProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

input UserProfileUpdateInput {
  bio: String
  isPublic: Boolean!
  website: String
}

type UserProjectsConnection {
  edges: [UserProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserProjectsConnectionEdge {
  cursor: String!
  node: Project!
}

type UserProviderAuthsConnection {
  edges: [UserProviderAuthsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserProviderAuthsConnectionEdge {
  cursor: String!
  node: ProviderAuth!
}

type UserTeamsConnection {
  edges: [UserTeamsConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserTeamsConnectionEdge {
  cursor: String!
  node: Team!
}

input UserUpdateInput {
  avatar: String
  name: String
  username: String
}

type Variable implements Node {
  createdAt: DateTime!
  environment: Environment!
  environmentId: String
  id: ID!
  isSealed: Boolean!
  name: String!
  plugin: Plugin!
  pluginId: String
  references: [String!]!
  service: Service!
  serviceId: String
  updatedAt: DateTime!
}

input VariableCollectionUpsertInput {
  environmentId: String!
  projectId: String!

  """
  When set to true, removes all existing variables before upserting the new collection.
  """
  replace: Boolean = false
  serviceId: String
  variables: EnvironmentVariables!
}

input VariableDeleteInput {
  environmentId: String!
  name: String!
  projectId: String!
  serviceId: String
}

input VariableUpsertInput {
  environmentId: String!
  name: String!
  projectId: String!
  serviceId: String
  value: String!
}

type VercelAccount {
  id: String!
  integrationAuthId: String!
  isUser: Boolean!
  name: String
  projects: [VercelProject!]!
  slug: String
}

type VercelInfo {
  accounts: [VercelAccount!]!
}

type VercelProject {
  accountId: String!
  id: String!
  name: String!
}

type Volume implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  project: Project!
  projectId: String!
  volumeInstances(after: String, before: String, first: Int, last: Int): VolumeVolumeInstancesConnection!
}

input VolumeCreateInput {
  """
  The environment to deploy the volume instances into. If `null`, the volume will not be deployed to any environment. `undefined` will deploy to all environments.
  """
  environmentId: String

  """The path in the container to mount the volume to"""
  mountPath: String!

  """The project to create the volume in"""
  projectId: String!

  """
  The service to attach the volume to. If not provided, the volume will be disconnected.
  """
  serviceId: String
}

type VolumeInstance implements Node {
  createdAt: DateTime!
  currentSizeMB: Float!
  environment: Environment!
  environmentId: String!
  externalId: String
  id: ID!
  mountPath: String!
  region: String
  service: Service!
  serviceId: String
  sizeMB: Int!
  state: VolumeState
  type: VolumeInstanceType!
  volume: Volume!
  volumeId: String!
}

type VolumeInstanceBackup {
  createdAt: DateTime!
  creatorId: String
  expiresAt: DateTime
  externalId: String!
  id: String!
  name: String
  referencedMB: Int
  usedMB: Int
}

type VolumeInstanceBackupSchedule implements Node {
  createdAt: DateTime!
  cron: String!
  id: ID!
  kind: VolumeInstanceBackupScheduleKind!
  name: String!
  retentionSeconds: Int
}

enum VolumeInstanceBackupScheduleKind {
  DAILY
  MONTHLY
  WEEKLY
}

type VolumeInstanceReplicationProgress {
  bytesTransferred: BigInt!
  percentComplete: Float!
  timestamp: DateTime!
  transferRateMbps: Float
}

enum VolumeInstanceType {
  CLOUD
  METAL
}

input VolumeInstanceUpdateInput {
  """
  The mount path of the volume instance. If not provided, the mount path will not be updated.
  """
  mountPath: String

  """
  The service to attach the volume to. If not provided, the volume will be disconnected.
  """
  serviceId: String

  """
  The state of the volume instance. If not provided, the state will not be updated.
  """
  state: VolumeState

  """
  The type of the volume instance. If not provided, the type will not be updated.
  """
  type: VolumeInstanceType
}

type VolumeReplicationProgressUpdate {
  currentSnapshot: VolumeSnapshotReplicationProgressUpdate!
  destExternalId: String!
  destRegion: String
  destStackerId: String
  error: String
  estimatedTimeRemainingMs: BigInt
  history: [VolumeInstanceReplicationProgress!]!
  nbSnapshots: Int!
  offlineBytesTransferred: BigInt!
  offlineTotalBytes: BigInt!
  onlineBytesTransferred: BigInt!
  onlineTotalBytes: BigInt!
  percentComplete: Float!
  snapshotsSizes: [BigInt!]!
  srcExternalId: String!
  srcRegion: String
  srcStackerId: String
  status: ReplicateVolumeInstanceStatus!
  transferRateMbps: Float
}

type VolumeSnapshotReplicationProgressUpdate {
  bytesTransferred: BigInt!
  compressedBytesTransferred: BigInt!
  compressedTransferRateMbps: Float
  elapsedMs: Int!
  error: String
  estimatedTimeRemainingMs: BigInt
  index: Int!
  percentComplete: Float!
  startedAt: DateTime
  status: ReplicateVolumeInstanceSnapshotStatus!
  totalBytes: BigInt!
  transferRateMbps: Float
}

enum VolumeState {
  DELETED
  DELETING
  ERROR
  MIGRATING
  MIGRATION_PENDING
  READY
  RESTORING
  UPDATING
}

input VolumeUpdateInput {
  """The name of the volume"""
  name: String
}

type VolumeVolumeInstancesConnection {
  edges: [VolumeVolumeInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}

type VolumeVolumeInstancesConnectionEdge {
  cursor: String!
  node: VolumeInstance!
}

input WebhookCreateInput {
  filters: [String!]
  projectId: String!
  url: String!
}

input WebhookUpdateInput {
  filters: [String!]
  url: String!
}

type Withdrawal implements Node {
  amount: Float!
  createdAt: DateTime!
  customerId: String!
  id: ID!
  status: WithdrawalStatusType!
  updatedAt: DateTime!
  withdrawalAccountId: String!
}

type WithdrawalAccount implements Node {
  customerId: String!
  id: ID!
  platform: WithdrawalPlatformTypes!
  platformDetails: String!
}

enum WithdrawalPlatformTypes {
  BMAC
  GITHUB
  PAYPAL
}

enum WithdrawalStatusType {
  CANCELLED
  COMPLETED
  FAILED
  PENDING
}

type WorkflowId {
  workflowId: String
}

type WorkflowResult {
  error: String
  status: WorkflowStatus!
}

enum WorkflowStatus {
  Complete
  Error
  NotFound
  Running
}

type Workspace implements Node {
  avatar: String
  banReason: String
  createdAt: DateTime!
  customer: Customer!
  discordRole: String
  id: ID!
  name: String!
  preferredRegion: String
  referredUsers: [ReferralUser!]!
  slackChannelId: String
  subscriptionModel: SubscriptionModel!
  supportTierOverride: SupportTierOverride
  team: Team
}

input WorkspaceUpdateInput {
  avatar: String
  name: String
  preferredRegion: String
}

input customerTogglePayoutsToCreditsInput {
  isWithdrawingToCredits: Boolean!
}
